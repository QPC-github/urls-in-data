<!DOCTYPE html> 
<html>
	<head> 
		<title>URLs in Data Primer</title> 
		<meta http-equiv='Content-Type' content='text/html;charset=utf-8'/> 
		<!-- 
			=== NOTA BENE ===
			For the three scripts below, if your spec resides on dev.w3 you can check them
			out in the same tree and use relative links so that they'll work offline,
		--> 
		<script src='http://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
		<script class='remove'> 
      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "urls-in-data",
 
          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "How to Use URLs in Data",
 
          // if you wish the publication date to be other than today, set this
          // publishDate:  "2012-10-03",
 
          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"
 
          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          previousPublishDate:  "2013-06-04",
          previousMaturity:  "FPWD",
 
          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://www.w3.org/2001/tag/doc/urls-in-data/",
 
          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",
 
          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
 //         extraCSS:             ["http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css"],
 
          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Jeni Tennison", url: "http://www.jenitennison.com/",
                company: "Open Data Institute", companyURL: "http://theodi.org/" }
          ],
 
          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.
 
          //authors:  [
          //    { name: "Your Name", url: "http://example.org/",
          //      company: "Your Company", companyURL: "http://example.com/" },
          //],
          
          // name of the WG
          wg:           "Technical Architecture Group",
          
          // URL of the public WG page
          wgURI:        "http://www.w3.org/2001/tag/",
          
          // name (with the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "www-tag",
          
          // URL of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URL from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "http://www.w3.org/2001/tag/disclosures",
      };
		</script>
		<style type="text/css">
			figure {
				font-style: italic;
				padding-left: 25%;
				padding-right: 25%;
			}
			figure p {
				text-align: center;
			}
			figure figcaption {
				font-weight: bold;
				text-align: center;
			}
		</style>
	</head> 
	<body> 
		<section id='abstract'> 
			<p>
				When a URL appears in data intended for consumption by applications, sometimes the data gives information about the content that can be retrieved from that URL, such as a biography or an image, while in other cases it gives information about the entity described or depicted by what is retrieved, such as a person or a farm. It's always useful to be able to retrieve the content at the URL, since the application can get either the entity or its description, and thus learns more about what is being talked about.  While humans can usually discriminate between these different modes of using URLs based on what "makes sense", applications cannot in general do so. Therefore, in standard formats for data, where we want reliable conclusions to be drawn from the data by an application, the context in which the URL occurs must make clear which mode is intended in each case.
			</p>
			<p>
				This document addresses this problem by describing how to define data formats and publish the information necessary to support an application in determining which of mode is intended when it encounters a URL in data.
			</p>
		</section> 
		
		<section id="sotd">
			<p>
				This is an Editor's Draft which the TAG intends to become a Working Draft on the Recommendation track at W3C.
			</p>
		</section>
		
		<section>
			<h2>Introduction</h2> 
			<p>
				Applications operate based on data that they receive or collect. For example, an application that works as an HTTP server might be sent data through an HTTP <code>POST</code> or <code>PUT</code> request. A mobile app might collect data by requesting it through <code>GET</code> requests on a web API.
			</p> 
			<p>
				The data that an application receives is a sequence of bits. The application interprets those bits through a series of processes &mdash; decoding, parsing, transforming and so on &mdash; to create an internal model based on which it can act. When the data includes URLs, those URLs may be used to inform the processing that builds the internal model, and the internal model may eventually include things that are named using the URLs that appeared in the data. Most importantly, the internal model may include <em>content</em> retrieved by resolving the URLs in the original data, and associate properties with that content based on the information associated with the URL in the original data.
			</p>
			<p>
				For example, Paul Downey has created an image of his poster <cite><a href="http://www.flickr.com/photos/psd/2918889380" rel="nofollow">The URI Is The Thing</a></cite> and made it available on a photo sharing site. Let us imagine that the photo sharing site exposes information about the poster in a number of ways, including through a JSON API. The JSON might look something like:
			</p>
			<pre class="example">
{
  "@id": "http://photo.example.com/psd/12345/original.jpeg",
  "type": "image",
  "creator": "Paul Downey",
  "license": "http://creativecommons.org/licenses/by/3.0/"
}
			</pre>
			<p>
				In this case, say the URL <code>http://photo.example.com/psd/12345/original.jpeg</code> resolves to a sequence of bits that encodes a JPEG image, and the JSON provided by the photo sharing site is intended to inform applications that that JPEG image was created by Paul Downey and can be reused elsewhere as long as it is attributed (as indicated by the licence). Knowing this, an application that accessed JSON from the site that included the above data could retrieve, store and process the bits retrieved from <code>http://photo.example.com/psd/12345/original.jpeg</code> (for example to extract <a href="https://en.wikipedia.org/wiki/Exchangeable_image_file_format">EXIF</a> data from the JPEG).
			</p>
			<p>
				In other cases, as described in <a href="#landing-pages" class="sectionRef"></a>, URLs used within data might point to <a title="landing page">landing pages</a> which <em>describe</em> the thing that has the properties specified in the data rather than <em>being</em> the thing that has those properties. To communicate effectively, data providers and applications need to have an agreed understanding about whether a given property provided in some data applies directly to the content at the given URL or to the thing that content describes. This document provides terminology and best practices to facilitate that shared understanding.
			</p>
			<p>
				This document purposefully does not address the question of what a context-free URL (for example, one on the side of a bus) identifies, or how this might be discovered. It is purely concerned with how an application can work out whether an assertion about a URL within some data is an assertion about the content found at that URL or about the thing described by that content.
			</p>
		</section>
		
		<section id="terminology">
			<h2>Terminology</h2>
			<p>
				There are lots of different ways of expressing data about things, the main standard ones currently in use on the web being JSON, XML and RDF. These are interpreted by applications into internal models. For the purpose of this document, we use the term <dfn>entity</dfn> for a thing about which we're passing information, and <dfn>property</dfn> as an asserted fact about an entity. An <a>entity</a> commonly has a corresponding data structure within an application, and <a title="property">properties</a> are fields of that data structure.
			</p>
			<p>
				In this document, we mostly use JSON to express information about <a title="entity">entities</a>, using the <a href="http://json-ld.org/">JSON-LD</a> convention of using <code>@id</code> as the means of providing a URL to name the <a>entity</a>. The same information could equally be expressed in XML in a variety of ways, such as:
			</p>
			<pre class="example">
&lt;image uri="http://photo.example.com/psd/12345/original.jpeg">
  &lt;creator>Paul Downey&lt;/creator>
  &lt;license href="http://creativecommons.org/licenses/by/3.0/" />
&lt;/image>
			</pre>
			<p>
				or in <a href="http://www.w3.org/TR/turtle/">Turtle</a> as a serialization of RDF:
			</p>
			<pre class="example">
PREFIX : &lt;http://example.org/>
&lt;http://photo.example.com/psd/12345/original.jpeg>
  a :Image ;
  :creator "Paul Downey" ;
  :license &lt;http://creativecommons.org/licenses/by/3.0/> ;
  .
			</pre>
			<p>
			  The same considerations apply when URLs are used to name entities, regardless of the format that is used to express the data.
			</p>
		</section>
		
		<section id="landing-pages">
			<h2>Landing Pages and Records</h2>
			<p>
				A <dfn>landing page</dfn> is any page whose primary purpose is to contain a description of something else. Landing pages often provide summaries or additional information about the thing that they describe. Examples are landing pages for images on Flickr or videos on YouTube, which are HTML pages that embed the media that they describe and provide access to comments and other metadata about it. Landing pages for documents are often tables of contents or abstracts.
			</p>
			<p>
				For example, say that the photo sharing site from the earlier example published an HTML page about <cite>The URI Is The Thing</cite> at <code>http://photo.example.com/psd/12345</code> which acts as a <a>landing page</a> for the photo, enabling people to add comments about it and providing links to other pictures by Paul Downey and so on. In this scenario, the site might publish the JSON:
			</p>
			<pre class="example">
{
  "@id": "http://photo.example.com/psd/12345",
  "type": "image",
  "creator": "Paul Downey",
  "license": "http://creativecommons.org/licenses/by/3.0/",
  "photo": "http://photo.example.com/psd/12345/original.jpeg"
}
			</pre>
			<p>
				Unlike the previous example, here it is <em>not</em> the case that the content an application gets when it resolves the value of the <code>@id</code> property (<code>http://photo.example.com/psd/12345</code>) is an image (contrary to the assertion of the <code>type</code> property) &mdash; it is an HTML page. Similarly, the content of the HTML page is not created by Paul Downey &mdash; it is created by the photo sharing site. The HTML page is not available under the CC-by licence &mdash; the photo sharing site holds the copyright. Thus the <a title="property">properties</a> that are associated with the URL <code>http://photo.example.com/psd/12345</code> within the data do not apply to the <em>content</em> provided at that URL, but to the image for which the HTML page is the <a>landing page</a>, and which is referenced in the <code>photo</code> property.
			</p>
			<p>
				This pattern also occurs with URLs that resolve to content that is not HTML: APIs that provide data in JSON, XML or RDF usually use URLs within that data which provide locations from which further information about the <a title="entity">entities</a> associated with the URLs can be discovered, again in JSON or XML or RDF. These JSON, XML or RDF <dfn title="record">records</dfn> are the machine-readable equivalent of HTML landing pages: they <em>describe</em> the image, video or other thing rather than being a sequence of bits that <em>is</em> that thing.
			</p>
			<p>
				Thus the same considerations would apply if the photo sharing site published the JSON above at the URL <code>http://photo.example.com/psd/12345</code>. The JSON that's published at that URL is not an image, it is a <a>record</a>. The site could alternatively use content negotiation to determine whether a given application receives the JSON or the HTML or some other format.
			</p>
			<p class="note">
				If the URL <code>http://photo.example.com/psd/12345</code> supported content negotiation such that a request with <code>Accept: text/html</code> provided an HTML page but a request with <code>Accept: image/jpeg</code> returned the image, the URL is being used for two distinct resources: the image and the <a>landing page</a>. The two resources have different values for important properties that cannot be content-negotiated on, such as their creator and license. As discussed in <a href="http://www.w3.org/TR/webarch/#id-resources">The Architecture of the World Wide Web</a> [[WEBARCH]], content negotiation should not be used between two different resources: instead, different resources should be named with different URLs. It is up to the publisher to determine whether two resources are different. 
			</p>
			<p>
				The photo sharing site may add information that <em>is</em> about the HTML landing page at the URL to the JSON data that it publishes. For example they might add a <code>last-modified</code> date that indicates the date and time that the landing page was last modified:
			</p>
			<pre class="example">
{
  "@id": "http://photo.example.com/psd/12345",
  "type": "image",
  "creator": "Paul Downey",
  "license": "http://creativecommons.org/licenses/by/3.0/",
  "photo": "http://photo.example.com/psd/12345/original.jpeg",
  "last-modified": "2012-06-20T08:54:32Z"
}
			</pre>
			<p>
				Doing this is potentially confusing because a developer simply looking at the output of the API and trying to make sense of it might assume that because the rest of the <a title="property">properties</a> associated with <code>http://photo.example.com/psd/12345</code> (such as <code>creator</code> or <code>license</code>) apply to the image <em>described by</em> the landing page at that URL, the <code>last-modified</code> <a>property</a> must apply to that image as well, when in fact it applies to the HTML landing page. Later sections describe methods for publishers to avoid confusing developers in this way.
			</p>
			<p>
				While the above example is of a <a>landing page</a> for an image where the image itself is available elsewhere on the web, publishers also provide landing pages for things that aren't available on the web, such as people or pieces of furniture. For example, the photo sharing site might publish a landing page for Paul Downey:
			</p>
			<pre class="example">
{
  "@id": "http://photo.example.com/psd",
  "type": "person",
  "name": "Paul Downey",
  "nickname": "psd"
}
			</pre>
			<p>
				When data is about something like a person or piece of furniture, it is usually obvious (to developers, who understand the world) that a given <a>property</a>, such as <code>nickname</code> or <code>dimensions</code>, doesn't apply to the landing page but to the person or piece of furniture that it describes. On the other hand, when the data is about something whose content <em>could</em> exist as data on the web, such as a photograph or a book or a film, that thing will often have <a title="property">properties</a> that could equally apply to the landing page itself, such as <code>creator</code> or <code>last-modified</code>.
			</p>
		</section>
		<section id="documenting-properties">
			<h2>Documenting Properties</h2>
			<p>
				As we have seen, the <a title="property">properties</a> used within data need to be documented to avoid developer confusion about what <a title="entity">entities</a> they apply to. A data format that mixes properties about landing pages or records and properties about the things those landing pages or records describe is not necessarily ambiguous: all that's required for developers to understand what the properties actually apply to is for the meaning of the property to be documented.
		  </p>
			<p id="property-categories">
				We recommend the use of the following terms to describe <a title="property">properties</a> within such documentation:
			</p>
			<dl>
				<dt><dfn>URL property</dfn></dt>
				<dd>a <a>property</a> that holds a URL for an <a>entity</a> to which the properties in the data are associated, often named something like <code>@id</code> or <code>url</code></dd>
				<dt><dfn>direct property</dfn></dt>
				<dd>a <a>property</a> that applies to the content retrieved from the URL given in the URL property for an <a>entity</a> (which may or may not be a <a>landing page</a> or <a>record</a>)</dd>
				<dt><dfn>shorthand property</dfn></dt>
				<dd>a <a>property</a> that indicates that the <a>entity</a> is a <a>landing page</a> that describes another entity which has a particular <a>implied property</a> with that value</dd>
				<dt><dfn>implied property</dfn></dt>
				<dd>a <a>property</a> on an entity that is implied through a <a>shorthand property</a> on a landing page</dd>
				<dt><dfn>parallel property</dfn></dt>
				<dd>an <a>implied property</a> where the <a>shorthand property</a> implies the presence of a landing page for another entity (see <a class="sectionRef" href="#url-values"></a>)</dd>
			</dl>
			<p>
				The following diagram shows how these properties interact:
			</p>
			<figure>
				<p><img src="property-types.png" /></p>
				<figcaption>Property categories</figcaption>
			</figure>
			<p>
				The term <a>shorthand property</a> can be used in a variety of cases, and documentation about shorthand properties needs to be particularly explicit about how they should be interpreted, as described in the following sub-sections.
			</p>
			<p>
				For example, in the JSON
			</p>
			<pre class="example">
{
  "@id": "http://photo.example.com/psd/12345",
  "type": "image",
  "creator": "Paul Downey",
  "license": "http://creativecommons.org/licenses/by/3.0/",
  "last-modified": "2012-06-20T08:54:32Z"
}
			</pre>
			<p>
				the properties might be documented as:
			</p>
			<dl class="example">
				<dt><code>@id</code></dt>
				<dd>a <a>URL property</a> for an HTML landing page</dd>
				<dt><code>type</code></dt>
				<dd>a <a>shorthand property</a> that implies the thing the landing page describes has the specified type</dd>
				<dt><code>creator</code></dt>
				<dd>a <a>shorthand property</a> that implies the thing the landing page describes has the specified creator</dd>
				<dt><code>license</code></dt>
				<dd>a <a>shorthand property</a> that implies the thing the landing page describes has the licence whose content is found at the location given</dd>
				<dt><code>last-modified</code></dt>
				<dd>a <a>direct property</a> which indicates when the content of the landing page was last modified</dd>
			</dl>
			<p>
				In this cases, "has type", "has creator" and "has license" are <a title="implied property">implied properties</a> which might not be described explicitly in the documentation. Graphically, we have:
			</p>
			<figure>
				<p><img src="implied-properties.png" /></p>
				<figcaption>Implied properties</figcaption>
			</figure>

			<section id="url-values">
				<h3>URL Values</h3>
				<p>
					<a title="property">Properties</a> may have values that are themselves URLs. In these cases, the property documentation should make clear whether the <em>entity URL</em> (provided by the <a>URL property</a> such as <code>@id</code>) points to a <a>landing page</a> or <a>record</a>, or the <em>value URL</em> (given in the value of the individual <a>property</a>) points to a landing page or record, or both. For example, in a case such as:
				</p>
				<pre class="example">
{
  "@id": "http://photo.example.com/psd/12345",
  "type": "image",
  "creator": "http://photo.example.com/psd",
  "license": "http://creativecommons.org/licenses/by/3.0/",
  "modified": "2012-06-20T08:54:32Z"
}
				</pre>
				<p>
					both the <code>creator</code> and the <code>license</code> properties are <a title="shorthand property">shorthand properties</a> of the image described by the <a>landing page</a> at the <a>entity</a> URL <code>http://photo.example.com/psd/12345</code>. However, the value of the <code>creator</code> property is <em>also</em> a landing page, this time for Paul Downey, whereas the value of the <code>license</code> property actually points to the content of the licence.
				</p>
				<p>
				  Properties between entities that are implied due to a property asserted between two landing pages or records are called <a title="parallel property">parallel properties</a> because in a diagram that shows the relationships between the landing pages and between the entities, these kinds of <a title="implied property">implied properties</a> will appear parallel to the <a>shorthand property</a>.
				</p>
				<p>
					The following diagram shows the <code>creator</code> <a>shorthand property</a>, whose value is a URL that points to a <a>landing page</a>, and how this property implies the existence of two entities &mdash; an image and a person &mdash; and a "has creator" relationship between those entities.
				</p>
				<figure>
					<p><img src="uri-property.png" /></p>
					<figcaption>URL Values</figcaption>
				</figure>
			</section>

			<section id="multi-faceted">
				<h3>Multi-Faceted Landing Pages and Records</h3>
				<p>
					Sometimes landing pages or records are about more than one thing, or the thing that they describe is functionally related to other things. In the example we've been using, the image <code>http://photo.example.com/psd/12345/original.jpeg</code> is actually a photograph of a poster which is about the web. What if the photograph of this poster had been taken by someone other than Paul Downey, and this was captured within the data? The JSON about its landing page might be:
				</p>
				<pre class="example">
{
  "@id": "http://photo.example.com/psd/12345",
  "type": "image",
  "photographer": "Nadia",
  "creator": "Paul Downey",
  "license": "http://creativecommons.org/licenses/by/3.0/",
  "last-modified": "2012-06-20T08:54:32Z"
}
				</pre>
				<p>
					In this case, the <code>photographer</code> property relates to the <em>photograph</em> described by the landing page at <code>http://photo.example.com/psd/12345</code> whereas the <code>creator</code> property relates to the <em>artwork</em> that was photographed.
				</p>
				<p>
					As this example shows, it is helpful to document the <em>kind of</em> the thing described by a <a>landing page</a> or <a>record</a> that a given <a>property</a> relates to. This enables an application, if it chooses to, to build an internal model of the data that includes separate <a title="entity">entities</a> for the landing page, each of the things that are described by the landing page, and the ways in which they are related.
				</p>
				<p>
				  In the example above, the documentation might include:
				</p>
  			<dl class="example">
  				<dt><code>photographer</code></dt>
  				<dd>a <a>shorthand property</a> that implies the landing page is about a photograph that was taken by a photographer with the given name</dd>
  				<dt><code>creator</code></dt>
  				<dd>a <a>shorthand property</a> that implies the landing page is about a creative work that was created by someone with the given name</dd>
  			</dl>
			</section>
			
			<section>
				<h3>Combining Data</h3>
				<p>
					One of the benefits of naming an <a>entity</a> with a URL is that it enables multiple sources of information to associate data with that entity by referring to the same URL. For example, a social networking site may provide JSON that states that someone likes the image described by <code>http://photo.example.com/psd/12345</code>:
				</p>
				<pre class="example">
{
  "@id": "http://social.example.com/dirk",
  "type": "person",
  "name": "Dirk",
  "likes": [
  	"http://photo.example.com/psd/12345",
  	...
  ]
}
				</pre>
				<p class="note">
					Here we assume that the <code>likes</code> property is defined as a <a>shorthand property</a> that implies that the content of the page at <code>http://photo.example.com/psd/12345</code> describes the thing that is liked. Without such documentation, some applications might adopt an alternative interpretation: that Dirk likes the web page at <code>http://photo.example.com/psd/12345</code>.
				</p>
				<p>
					A review site might similarly provide JSON that describes a review of the image at <code>http://photo.example.com/psd/12345</code> (again we assume here that the documentation of the <code>subject</code> property describes that the review is about the thing described by the landing page at the given URL):
				</p>
				<pre class="example">
{
  "@id": "http://review.example.com/jane/12345",
  "type": "review",
  "subject": "http://photo.example.com/psd/12345",
  "rating": 5
}
				</pre>
				<p>
					As discussed in <a href="#multi-faceted" class="sectionRef"></a>, the <a>landing page</a> at <code>http://photo.example.com/psd/12345</code> may describe many things. If a search engine or other application were to merge the information from the three sites, it would need to associate both the "like" and the review to the same <a>entity</a> &mdash; the image.
				</p>
				<p>
					The publishers of the image could help applications to combine information about the image across the sites accurately by supplying a separate URL for the image itself, linked to from the <a>landing page</a> with a specific relationship (such as <code>describesImage</code>) through a <code>Link</code> HTTP header or a <code>&lt;link&gt;</code> element within the landing page. To be clear about what is being liked or reviewed, the social media site and the review site could either reference that image directly, or describe their <a title="shorthand property">shorthand properties</a> in terms of the <code>describesImage</code> property of the landing page.
				</p>
			</section>
			
			<section>
			  <h3>Locating Property Documentation</h3>
  		  <p>
  		    The previous sections have discussed how important it is to have documentation that includes information about how URLs used within data should be interpreted and specifically whether <a title="property">properties</a> within the data apply to the content found at a URL or to something that content describes. This documentation should be published somewhere such that it's possible for those developers to find it. Possible routes for doing this explicitly include:
  			</p>
  			<ul>
  				<li>if the data is provided through a protocol that supports it, such as through HTTP, by explicitly indicating the media type of the data, and <a href="http://tools.ietf.org/html/rfc6838">registering that media type</a> such that documentation can be found for it through the <a href="http://www.iana.org/assignments/media-types">IANA media type registry</a></li>
  				<li>if the media type is generic (such as <code>application/json</code>), by providing supplementary documentation through a <a href="http://tools.ietf.org/html/draft-wilde-profile-link-04"><code>profile</code> link relationship</a>, for example within a <a href="http://tools.ietf.org/html/rfc5988">HTTP <code>Link</code> header</a></li>
  				<li>embedding links to the documentation within the data itself, for example through a resolvable XML namespace or <a href="http://www.w3.org/TR/xmlschema11-1/#schema-loc"><code>@xsi:schemaLocation</code> attribute</a> in XML or by using resolvable URLs for classes and properties in RDF</li>
  			</ul>
  			<p>
  				Developers should be able to locate this documentation through a mechanism that isn't a search against the Internet. If the <a>property</a> documentation should be accessed through resolving URLs within the data (the last of the options above), this mechanism should be specified within the media type definition or the documentation provided through the <code>profile</code> link relationship.
  			</p>
  			<p class="issue">
  				What if the data isn't made available by HTTP and you therefore don't have a media type: how does follow-your-nose work in that case? For example, if the data is provided via FTP or embedded within a textual email message.
  			</p>
			</section>
		</section>
		
		<section>
			<h2>Recommendations</h2>
			<p>
				This section makes concrete recommendations for data consumers, data publishers and the authors of specifications that use URLs, based on the discussion above.
			</p>
			<section id="authoring-specifications">
				<h3>Authoring Specifications</h3>
				<p>
					Data formats that include URLs should specify what <a title="property">properties</a> an application can associate with the <a title="entity">entities</a> named by those URLs, based on how the URLs are used within the document and on the other data found within the document. They should also specify what applications can expect to find at the end of these URLs: in particular whether the URL is being used to reference the <em>content</em> found at that URL, or something <em>described by</em> that content. 
				</p>
				<p>
					For example, the <a href="http://www.w3.org/TR/xml/">XML Recommendation</a> [[XML10]] specifies that URLs used within the <code>&lt;!DOCTYPE&gt;</code> declaration must resolve to documents that are well-formed external subsets: this places some clear expectations on what publishers should publish at these URLs, and on implementers in terms of how applications should process them.
				</p>
				<p>
					By contrast, the <a href="http://www.w3.org/TR/xml-names/">Namespaces in XML Recommendation</a> [[XML-NAMES]] does not specify how the URLs used within XML namespace declarations should be processed, over and above how to compare them. It does not say whether applications can resolve them, or what should be found if they are resolved. The <a href="http://www.w3.org/TR/2004/REC-webarch-20041215/#namespace-document">Architecture of the World Wide Web</a> states that these URLs should resolve to "namespace documents", but leaves open whether these should be machine-readable schemas, or landing pages from which schemas can be located, as described in the TAG Finding <a href="http://www.w3.org/2001/tag/doc/nsDocuments/">Associating Resources with Namespaces</a>.
				</p>
				<p>
					Formats that are designed to be used to provide metadata about HTML pages, images, video and other information on the web should default to an interpretation in which properties are associated with the <em>content</em> that is found by resolving the URLs. Those that are designed to encode data about things that are not found on the web should default to an interpretation in which the properties are associated with the things that <em>described by</em> the documents located by the URLs.
				</p>
				
				<section>
				  <h4>Specifying Metaformats</h4>
				  <p>
				    Metaformats such as RDF that incorporate URLs as part of their core information model should document the default interpretation of those URLs: whether properties for which no other information is available should be interpreted as applying to the <em>content</em> available at those URLs or the things those documents <em>describe</em>.
				  </p>
				  <p>
				    Metaformats may delegate how properties are interpreted to individual vocabularies that use the metaformat, such that different properties within a vocabulary using the metaformat fall into different categories, as described in <a class="sectionRef" href="#documenting-properties"></a>. Making the interpretation of a URL dependent on the property with which it is used requires applications to have information about the particular vocabulary being used in order to know what to do with a URL. Most applications need to understand a vocabulary being used to take relevant action on the basis of a set of data, but generic applications will benefit from schema languages that encode this information in a machine-readable way, as described in <a class="sectionRef" href="#specifying-schema-languages"></a>.
				  </p>
				</section>
				<section>
				  <h4>Specifying Vocabularies</h4>
				  <p>
				    Authors of vocabularies that are used with metaformats such as XML, JSON or RDF and that reference URLs should document how data expressed in those vocabularies should be interpreted. The vocabulary should be documented in terms of the <a title="entity">entities</a> that data using that vocabulary describes, and how the <a title="property">properties</a> within the vocabulary should be interpreted, whether as being properties of content on the web located at the referenced URLs or of the things described by <a title="landing page">landing pages</a> or <a title="record">records</a> located at those URLs. This interpretation may vary on a property-by-property basis, in which case the properties should be documented using the terminology given in <a class="sectionRef" href="#documenting-properties"></a>.
				  </p>
				</section>
				<section id="specifying-schema-languages">
				  <h4>Specifying Schema Languages</h4>
				  <p>
					  Schema languages should include mechanisms for indicating the <a href="#property-categories">category of a property</a> as described in <a href="#documenting-properties" class="sectionRef"></a>. This encourages vocabulary authors to be explicit in their property documentation, and it enables applications to automatically create a suitable internal model, without prior knowledge of the vocabulary.
				  </p>
				  <p>
					  In some cases, vocabulary authors may wish to provide names within a vocabulary for <a title="implied property">implied properties</a> in order to express the relationship between them and <a title="shorthand property">shorthand properties</a>. Alternatively, the presence of shorthand properties within data that uses one vocabulary may imply the existence of entities with properties from a different vocabulary. Schemas may provide the facility to specify the implications of the presence of each shorthand property in terms of implied entities and their properties.
				  </p>
				</section>
			</section>
			<section>
				<h3>Consuming Data</h3>
				<p>
					Applications that consume data on the web may need to determine, based on a given set of data, which <a title="property">properties</a> can be associated with the content found on the web at a given URL. Applications that commonly need to do this include crawlers that need to work out the licence that applies to a particular piece of content, or to whom it should be attributed. Applications should work out which properties apply to a piece of content based on the media type of the data that contains the information about the URL. Media types for structured syntaxes such as JSON, XML or Turtle may delegate how to interpret data to a vocabulary, defined in a schema or in separate documentation.
				</p>
				<p>
					Applications should be wary, in the absence of explicit indications within specifications or vocabularies, about associating properties with the <em>content</em> located at a given URL used within a <a>URL property</a> for an <a>entity</a>. Some publishers may intend the properties to be associated with the content an application gets when it resolves the URL, while others intend them to be associated with an entity described by the content. Applications should be particularly careful in interpreting properties that could be associated with content retrieved from the web, such as "like" or "creator".
				</p>
				<section id="http-responses">
				  <h4>HTTP Responses</h4>
					<p>
						The response received when resolving a <code>http:</code> or <code>https:</code> URL does not affect how a given piece of data that refers to that URL is interpreted, but applications may use it to infer additional properties. For example, the HTTP headers that are included in an HTTP response encode properties, such as the last modification date, which are usually associated with the HTTP entity body contained within the response. The <code>Link</code> header in particular provides additional data which may be about the specific HTTP entity body, a more abstract notion of the document located by the URL (which may change over time or be available in multiple content-negotiated variants), or something described by that document. The documentation of the link relation used within the <code>Link</code> header should provide specific information about how the relation should be interpreted in relation to the resolved URL.
					</p>
					<p>
						The most important property of a URL, whose value can only be discovered through resolution, is its content. The actual content located through resolving a URL may change over time or based on aspects of the request (such as <code>Accept</code> headers). Where data makes assertions about the content of a URL, these assertions are taken to apply to those aspects of the content that remain constant across these variants. Applications can only sample this content at any particular point in time, and some HTTP responses may only provide a portion of the content associated with the URL.
					</p>
					<p>
						URLs that include fragment identifiers are known as <dfn title="hash URL">hash URLs</dfn>. When presented with a hash URL, such as <code>http://photo.example.com/psd/12345#comment-67890</code> or <code>http://photo.example.com/psd#me</code>, applications can locate its content by resolving the base URL (before the fragment identifier) and interpreting the fragment identifier based on the fragment identifier rules specified for the media type of the the response. In some cases this will resolve to some content (such as an XML or HTML element); in other cases it may not. In cases where the fragment identifier does not resolve to any content in a given response, applications can infer that the content at the base URL <em>describes</em> the <a>entity</a> named with that hash URL.
					</p>
					<p>
						When resolving a URL results in a <code>303 See Other</code> response, applications can infer that the content found at the URL given in the <code>Location</code> header of that response <em>describes</em> the <a>entity</a> named with the original URL. Other redirections (such as <code>301 Permanent Redirect</code> or <code>307 Temporary Redirect</code>) imply that applications can get the content of the original URL by looking instead at the content retrieved from the URL given in the <code>Location</code> header. Error status codes such as <code>404 Not Found</code> do not imply anything about the content associated with a given URL, except that it cannot be provided by the server.
					</p>
					<p>
						The ability to have URLs that do not have associated content (hash URLs that do not resolve to a document fragment or URLs that give a <code>303 See Other</code> response) means that <a title="direct property">direct properties</a>, which refer to the content retrieved from a given URL, can be used to describe things which are not yet on the web. For example, if the property <code>creator</code> were defined as a direct property that specifies the creator of the content found at a given URL, it could also be used in data that described a book whose content is not currently on the web. In this case, the URL used for the book must be a hash URL that does not resolve to a document fragment, or give a <code>303</code> response.
					</p>
				</section>
			</section>
			<section>
				<h3>Publishing Data</h3>
				<p>
					Publishers can help enable more accurate merging of data from different sites if they support URLs for each <a>entity</a> they or other sites may wish to describe, separate from the <a title="landing page">landing pages</a> or <a title="record">records</a> that they publish. If these additional URLs are provided, the HTTP response given when resolving a landing page or record should include a <code>Link</code> header indicating the URL of the entity the landing page or record describes using the <code>describes</code> relationship. Similarly, if there are pages that describe the entity associated with a given URL, then:
				</p>
				<ul>
					<li>if the URL is a hash URL, the base URL should be that of the document that describes the entity</li>
					<li>if the content of the entity is available on the web, the response should include a <code>Link</code> header with the <code>describedby</code> relationship, linking to the landing page or record</li>
					<li>otherwise, the URL should result in a <code>303 See Other</code> HTTP status code, redirecting to the landing page or record</li>
				</ul>
			</section>
		</section>

		<section class='appendix'> 
			<h2>Acknowledgements</h2> 
			<p> 
				Many thanks in particular to Jonathan Rees and Henry Thompson for the technical work behind this draft, and to Robin Berjon for <a href="http://respec.specifiction.com/">ReSpec.js</a>.
			</p> 
		</section>
		
		<section class="appendix">
			<h2>Concrete Recommendations</h2>
			<p>
				There are many existing data formats, metaformats, vocabularies and schema languages that do not document their use of URLs in the ways described in this document. This section lists them.
			</p>
			<dl>
				<dt>RDF</dt>
				<dd>URLs are used to name RDF "resources", and RDF makes statements about these resources. RDF does not state whether the properties apply to the content found by resolving those URLs or to the things described by that content.</dd>
				<dt>microdata</dt>
				<dd>URLs are used to give global identifiers to microdata "items" using the <code>@itemid</code> attribute, and as values for properties when the <code>@href</code> or <code>@src</code> attribute is used. The meaning of the identifier and of the values of properties is specified as determined by the vocabulary that's used with microdata. No change is need here, although the specification could make it clearer that the interpretation of URLs used in these contexts should be specified within the vocabulary.</dd>
				<dt>schema.org</dt>
				<dd>The schema.org vocabulary includes the <code>url</code> property, and when expressed in microdata publishers may use the <code>@itemid</code> attribute or in RDFa the <code>@resource</code> attribute to provide a URL. Most properties appear to be designed to apply to the thing described by the document found at the URL given by the <code>url</code> property, but this is not made explicit in the documentation.</dd>
				<dt><code>Link</code> headers</dt>
				<dd>The <code>Link</code> header expresses a property with a URL value, like those described in <a href="#url-values" class="sectionRef"></a>. The documentation for each link relation should describe whether the property relates to the HTTP entity body included in the response, to the more abstract notion of the content retrieved from the URL as described in <a href="#http-responses" class="sectionRef"></a>, or to something described by that content. Similarly, the documentation should describe whether the value of the property is the content of the target URL or the thing described by that content.</dd>
				<dt>XML Namespaces</dt>
				<dd>As discussed in <a href="#authoring-specifications" class="sectionRef"></a>, the XML Namespaces Recommendation [[XML-NAMES]] does not specify how URLs used within XML namespace declarations should be interpreted by applications.</dd>
			</dl>
		</section>
		
		<section class="appendix">
			<h2>Background</h2>
			<p>This document is one output from the TAG's (re)consideration of</p>
			
			<ul>
				<li><a href="http://www.w3.org/2001/tag/group/track/issues/14">ISSUE-14</a> (otherwise known as httpRange-14) which asks "What is the range of the HTTP dereference function" or in other words "what kind of things can URLs dereference to"</li>
				<li><a href="http://www.w3.org/2001/tag/group/track/issues/57">ISSUE-57</a> which asks for "Mechanisms for obtaining information about the meaning of a given URL"</li>
			</ul>
			
			
			<p>ISSUE-14 was originally closed by the TAG in 2005 with a <a href="http://lists.w3.org/Archives/Public/www-tag/2005Jun/0039.html">decision provided by email</a> that stated:</p>
			
			<pre>That we provide advice to the community that they may mint
"http" URLs for any resource provided that they follow this
simple rule for the sake of removing ambiguity:

  a) If an "http" resource responds to a GET request with a
     2xx response, then the resource identified by that URL
     is an information resource;

  b) If an "http" resource responds to a GET request with a
     303 (See Other) response, then the resource identified
     by that URL could be any resource;

  c) If an "http" resource responds to a GET request with a
     4xx (error) response, then the nature of the resource
     is unknown.
</pre>
			
			<p>Experience since that decision has highlighted problems with this resolution, such as:</p>
			
			<ul>
				<li>confusion over the meaning of "information resource"</li>
				<li>implementation issues with using <code>303 See Other</code> responses</li>
			</ul>
			
			
			<p>The various other options and their strengths and weaknesses are explored in <a href="http://www.w3.org/2001/tag/awwsw/issue57/20120202/">Providing and Discovering URL Documentation</a>.</p>
			
			<p>This issue has traditionally been seen as only a problem for philosophers and the Semantic Web / Linked Data community. However, there is growing adoption of RESTful APIs that provide data describing web-based documents and real-world things and that use URLs to refer to the entities that are described by the data, and who face the same issues.</p>
			
			<p>The TAG has, over the past several years, put significant effort into both exploring the implications of the 2005 TAG decision and the various alternatives that have been espoused.</p>
			
			<p>In February 2012, the TAG issued a <a href="http://www.w3.org/2001/tag/doc/uddp/change-proposal-call.html">call for change proposals</a> on a formalisation of the TAG decision, <a href="http://www.w3.org/2001/tag/doc/uddp-20120229/">Understanding URL Hosting Practice as Support for URL Documentation Discovery</a>. This led to a number of <a href="http://www.w3.org/wiki/TagIssue57Responses">responses which are summarised within the wiki</a>.</p>
			
			<p>The TAG put together a number of <a href="http://www.w3.org/wiki/HTTPURIUseCases">use cases</a> and assessed the various proposals against those use cases within a <a href="http://www.w3.org/wiki/HTTPURIUseCaseMatrix">matrix</a>. Based on this analysis, the most promising direction was identified to be the <a href="http://decentralyze.com/2010/11/10/simplified-rdf/">"parallel properties" proposal</a>. At the <a href="http://www.w3.org/2001/tag/2012/06/14-minutes#item01">June 2012 F2F</a>, the TAG discussed this approach and agreed that it was the right direction. Further work was then done prior to the October 2012 F2F, where it was <a href="http://www.w3.org/2001/tag/2012/10/08-minutes#item02">discussed again</a>.</p>
			
			<p>At that point, the TAG resolved to:</p>
			
			<ol>
				<li> Go back to community with perspective from background section on what URLs can or can't be known to identify as the response to change proposals</li>
				<li> publish URLs in Data primer (this document) as a rec</li>
				<li> publish a note base on proposal 27 with intention to transition to RDF WG</li>
			</ol>
		</section>
	</body> 
</html> 